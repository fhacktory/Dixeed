import IO = require('./io');
import Device = IO.Device;
export declare class MotorBase extends Device {
    protected _deviceIndex: number;
    deviceIndex: number;
    constructor(driverTypeDirName: string, nameConvention: string, targetAddress?: string, targetDriverName?: string | string[]);
}
/**
 * The motor class provides a uniform interface for using motors with
 * positional and directional feedback such as the EV3 and NXT motors.
 * This feedback allows for precise control of the motors. This is the
 * most common type of motor, so we just call it `motor`.
 */
export declare class Motor extends MotorBase {
    constructor(port?: string, targetDriverName?: string[] | string);
    reset(): void;
    stop(): void;
    /**
     * Sends a command to the motor controller. See `commands` for a list of
     * possible values.
     */
    command: string;
    /**
     * Returns a list of commands that are supported by the motor
     * controller. Possible values are `run-forever`, `run-to-abs-pos`, `run-to-rel-pos`,
     * `run-timed`, `run-direct`, `stop` and `reset`. Not all commands may be supported.
     *
     * - `run-forever` will cause the motor to run until another command is sent.
     * - `run-to-abs-pos` will run to an absolute position specified by `position_sp`
     *   and then stop using the command specified in `stop_command`.
     * - `run-to-rel-pos` will run to a position relative to the current `position` value.
     *   The new position will be current `position` + `position_sp`. When the new
     *   position is reached, the motor will stop using the command specified by `stop_command`.
     * - `run-timed` will run the motor for the amount of time specified in `time_sp`
     *   and then stop the motor using the command specified by `stop_command`.
     * - `run-direct` will run the motor at the duty cycle specified by `duty_cycle_sp`.
     *   Unlike other run commands, changing `duty_cycle_sp` while running *will*
     *   take effect immediately.
     * - `stop` will stop any of the run commands before they are complete using the
     *   command specified by `stop_command`.
     * - `reset` will reset all of the motor parameter attributes to their default value.
     *   This will also have the effect of stopping the motor.
     */
    commands: string[];
    /**
     * Returns the number of tacho counts in one rotation of the motor. Tacho counts
     * are used by the position and speed attributes, so you can use this value
     * to convert rotations or degrees to tacho counts. In the case of linear
     * actuators, the units here will be counts per centimeter.
     */
    countPerRot: number;
    /**
     * Returns the name of the driver that provides this tacho motor device.
     */
    driverName: string;
    /**
     * Returns the current duty cycle of the motor. Units are percent. Values
     * are -100 to 100.
     */
    dutyCycle: number;
    /**
     * Writing sets the duty cycle setpoint. Reading returns the current value.
     * Units are in percent. Valid values are -100 to 100. A negative value causes
     * the motor to rotate in reverse. This value is only used when `speed_regulation`
     * is off.
     */
    /**
     * Writing sets the duty cycle setpoint. Reading returns the current value.
     * Units are in percent. Valid values are -100 to 100. A negative value causes
     * the motor to rotate in reverse. This value is only used when `speed_regulation`
     * is off.
     */
    dutyCycleSp: number;
    /**
     * Sets the polarity of the rotary encoder. This is an advanced feature to all
     * use of motors that send inversed encoder signals to the EV3. This should
     * be set correctly by the driver of a device. It You only need to change this
     * value if you are using a unsupported device. Valid values are `normal` and
     * `inversed`.
     */
    /**
     * Sets the polarity of the rotary encoder. This is an advanced feature to all
     * use of motors that send inversed encoder signals to the EV3. This should
     * be set correctly by the driver of a device. It You only need to change this
     * value if you are using a unsupported device. Valid values are `normal` and
     * `inversed`.
     */
    encoderPolarity: string;
    /**
     * Sets the polarity of the motor. With `normal` polarity, a positive duty
     * cycle will cause the motor to rotate clockwise. With `inversed` polarity,
     * a positive duty cycle will cause the motor to rotate counter-clockwise.
     * Valid values are `normal` and `inversed`.
     */
    /**
     * Sets the polarity of the motor. With `normal` polarity, a positive duty
     * cycle will cause the motor to rotate clockwise. With `inversed` polarity,
     * a positive duty cycle will cause the motor to rotate counter-clockwise.
     * Valid values are `normal` and `inversed`.
     */
    polarity: string;
    /**
     * Returns the name of the port that this motor is connected to.
     */
    address: string;
    /**
     * Returns the current position of the motor in pulses of the rotary
     * encoder. When the motor rotates clockwise, the position will increase.
     * Likewise, rotating counter-clockwise causes the position to decrease.
     * Writing will set the position to that value.
     */
    /**
     * Returns the current position of the motor in pulses of the rotary
     * encoder. When the motor rotates clockwise, the position will increase.
     * Likewise, rotating counter-clockwise causes the position to decrease.
     * Writing will set the position to that value.
     */
    position: number;
    /**
     * The proportional constant for the position PID.
     */
    /**
     * The proportional constant for the position PID.
     */
    positionP: number;
    /**
     * The integral constant for the position PID.
     */
    /**
     * The integral constant for the position PID.
     */
    positionI: number;
    /**
     * The derivative constant for the position PID.
     */
    /**
     * The derivative constant for the position PID.
     */
    positionD: number;
    /**
     * Writing specifies the target position for the `run-to-abs-pos` and `run-to-rel-pos`
     * commands. Reading returns the current value. Units are in tacho counts. You
     * can use the value returned by `counts_per_rot` to convert tacho counts to/from
     * rotations or degrees.
     */
    /**
     * Writing specifies the target position for the `run-to-abs-pos` and `run-to-rel-pos`
     * commands. Reading returns the current value. Units are in tacho counts. You
     * can use the value returned by `counts_per_rot` to convert tacho counts to/from
     * rotations or degrees.
     */
    positionSp: number;
    /**
     * Returns the current motor speed in tacho counts per second. Not, this is
     * not necessarily degrees (although it is for LEGO motors). Use the `count_per_rot`
     * attribute to convert this value to RPM or deg/sec.
     */
    speed: number;
    /**
     * Writing sets the target speed in tacho counts per second used when `speed_regulation`
     * is on. Reading returns the current value.  Use the `count_per_rot` attribute
     * to convert RPM or deg/sec to tacho counts per second.
     */
    /**
     * Writing sets the target speed in tacho counts per second used when `speed_regulation`
     * is on. Reading returns the current value.  Use the `count_per_rot` attribute
     * to convert RPM or deg/sec to tacho counts per second.
     */
    speedSp: number;
    /**
     * Writing sets the ramp up setpoint. Reading returns the current value. Units
     * are in milliseconds. When set to a value > 0, the motor will ramp the power
     * sent to the motor from 0 to 100% duty cycle over the span of this setpoint
     * when starting the motor. If the maximum duty cycle is limited by `duty_cycle_sp`
     * or speed regulation, the actual ramp time duration will be less than the setpoint.
     */
    /**
     * Writing sets the ramp up setpoint. Reading returns the current value. Units
     * are in milliseconds. When set to a value > 0, the motor will ramp the power
     * sent to the motor from 0 to 100% duty cycle over the span of this setpoint
     * when starting the motor. If the maximum duty cycle is limited by `duty_cycle_sp`
     * or speed regulation, the actual ramp time duration will be less than the setpoint.
     */
    rampUpSp: number;
    /**
     * Writing sets the ramp down setpoint. Reading returns the current value. Units
     * are in milliseconds. When set to a value > 0, the motor will ramp the power
     * sent to the motor from 100% duty cycle down to 0 over the span of this setpoint
     * when stopping the motor. If the starting duty cycle is less than 100%, the
     * ramp time duration will be less than the full span of the setpoint.
     */
    /**
     * Writing sets the ramp down setpoint. Reading returns the current value. Units
     * are in milliseconds. When set to a value > 0, the motor will ramp the power
     * sent to the motor from 100% duty cycle down to 0 over the span of this setpoint
     * when stopping the motor. If the starting duty cycle is less than 100%, the
     * ramp time duration will be less than the full span of the setpoint.
     */
    rampDownSp: number;
    /**
     * Turns speed regulation on or off. If speed regulation is on, the motor
     * controller will vary the power supplied to the motor to try to maintain the
     * speed specified in `speed_sp`. If speed regulation is off, the controller
     * will use the power specified in `duty_cycle_sp`. Valid values are `on` and
     * `off`.
     */
    /**
     * Turns speed regulation on or off. If speed regulation is on, the motor
     * controller will vary the power supplied to the motor to try to maintain the
     * speed specified in `speed_sp`. If speed regulation is off, the controller
     * will use the power specified in `duty_cycle_sp`. Valid values are `on` and
     * `off`.
     */
    speedRegulationEnabled: string;
    /**
     * The proportional constant for the speed regulation PID.
     */
    /**
     * The proportional constant for the speed regulation PID.
     */
    speedRegulationP: number;
    /**
     * The integral constant for the speed regulation PID.
     */
    /**
     * The integral constant for the speed regulation PID.
     */
    speedRegulationI: number;
    /**
     * The derivative constant for the speed regulation PID.
     */
    /**
     * The derivative constant for the speed regulation PID.
     */
    speedRegulationD: number;
    /**
     * Reading returns a list of state flags. Possible flags are
     * `running`, `ramping` `holding` and `stalled`.
     */
    state: string[];
    /**
     * Reading returns the current stop command. Writing sets the stop command.
     * The value determines the motors behavior when `command` is set to `stop`.
     * Also, it determines the motors behavior when a run command completes. See
     * `stop_commands` for a list of possible values.
     */
    /**
     * Reading returns the current stop command. Writing sets the stop command.
     * The value determines the motors behavior when `command` is set to `stop`.
     * Also, it determines the motors behavior when a run command completes. See
     * `stop_commands` for a list of possible values.
     */
    stopCommand: string;
    /**
     * Returns a list of stop modes supported by the motor controller.
     * Possible values are `coast`, `brake` and `hold`. `coast` means that power will
     * be removed from the motor and it will freely coast to a stop. `brake` means
     * that power will be removed from the motor and a passive electrical load will
     * be placed on the motor. This is usually done by shorting the motor terminals
     * together. This load will absorb the energy from the rotation of the motors and
     * cause the motor to stop more quickly than coasting. `hold` does not remove
     * power from the motor. Instead it actively try to hold the motor at the current
     * position. If an external force tries to turn the motor, the motor will 'push
     * back' to maintain its position.
     */
    stopCommands: string[];
    /**
     * Writing specifies the amount of time the motor will run when using the
     * `run-timed` command. Reading returns the current value. Units are in
     * milliseconds.
     */
    /**
     * Writing specifies the amount of time the motor will run when using the
     * `run-timed` command. Reading returns the current value. Units are in
     * milliseconds.
     */
    timeSp: number;
    applySpeedSp(newSp: number | MotorSpeedSp): void;
    sendCommand(commandName: string): void;
    runForever(sp?: MotorSpeedSp | number): void;
    start(sp?: MotorSpeedSp | number): void;
    runToPosition(position?: number, speedSp?: MotorSpeedSp | number): void;
    runToAbsolutePosition(position?: number, speedSp?: MotorSpeedSp | number): void;
    runForDistance(distance?: number, speedSp?: MotorSpeedSp | number): void;
    runToRelativePosition(relPos?: number, speedSp?: MotorSpeedSp | number): void;
}
/**
 * EV3 large servo motor
 */
export declare class LargeMotor extends Motor {
    constructor(port?: string);
}
/**
 * EV3 medium servo motor
 */
export declare class MediumMotor extends Motor {
    constructor(port?: string);
}
/**
 * The DC motor class provides a uniform interface for using regular DC motors
 * with no fancy controls or feedback. This includes LEGO MINDSTORMS RCX motors
 * and LEGO Power Functions motors.
 */
export declare class DCMotor extends MotorBase {
    constructor(port: string);
    /**
     * Sets the command for the motor. Possible values are `run-forever`, `run-timed` and
     * `stop`. Not all commands may be supported, so be sure to check the contents
     * of the `commands` attribute.
     */
    command: string;
    /**
     * Returns a list of commands supported by the motor
     * controller.
     */
    commands: string[];
    /**
     * Returns the name of the motor driver that loaded this device. See the list
     * of [supported devices] for a list of drivers.
     */
    driverName: string;
    /**
     * Shows the current duty cycle of the PWM signal sent to the motor. Values
     * are -100 to 100 (-100% to 100%).
     */
    dutyCycle: number;
    /**
     * Writing sets the duty cycle setpoint of the PWM signal sent to the motor.
     * Valid values are -100 to 100 (-100% to 100%). Reading returns the current
     * setpoint.
     */
    /**
     * Writing sets the duty cycle setpoint of the PWM signal sent to the motor.
     * Valid values are -100 to 100 (-100% to 100%). Reading returns the current
     * setpoint.
     */
    dutyCycleSp: number;
    /**
     * Sets the polarity of the motor. Valid values are `normal` and `inversed`.
     */
    /**
     * Sets the polarity of the motor. Valid values are `normal` and `inversed`.
     */
    polarity: string;
    /**
     * Returns the name of the port that this motor is connected to.
     */
    address: string;
    /**
     * Sets the time in milliseconds that it take the motor to ramp down from 100%
     * to 0%. Valid values are 0 to 10000 (10 seconds). Default is 0.
     */
    /**
     * Sets the time in milliseconds that it take the motor to ramp down from 100%
     * to 0%. Valid values are 0 to 10000 (10 seconds). Default is 0.
     */
    rampDownSp: number;
    /**
     * Sets the time in milliseconds that it take the motor to up ramp from 0% to
     * 100%. Valid values are 0 to 10000 (10 seconds). Default is 0.
     */
    /**
     * Sets the time in milliseconds that it take the motor to up ramp from 0% to
     * 100%. Valid values are 0 to 10000 (10 seconds). Default is 0.
     */
    rampUpSp: number;
    /**
     * Gets a list of flags indicating the motor status. Possible
     * flags are `running` and `ramping`. `running` indicates that the motor is
     * powered. `ramping` indicates that the motor has not yet reached the
     * `duty_cycle_sp`.
     */
    state: string[];
    /**
     * Sets the stop command that will be used when the motor stops. Read
     * `stop_commands` to get the list of valid values.
     */
    stopCommand: string;
    /**
     * Gets a list of stop commands. Valid values are `coast`
     * and `brake`.
     */
    stopCommands: string[];
    /**
     * Writing specifies the amount of time the motor will run when using the
     * `run-timed` command. Reading returns the current value. Units are in
     * milliseconds.
     */
    /**
     * Writing specifies the amount of time the motor will run when using the
     * `run-timed` command. Reading returns the current value. Units are in
     * milliseconds.
     */
    timeSp: number;
}
/**
 * The servo motor class provides a uniform interface for using hobby type
 * servo motors.
 */
export declare class ServoMotor extends MotorBase {
    constructor(port: string);
    /**
     * Sets the command for the servo. Valid values are `run` and `float`. Setting
     * to `run` will cause the servo to be driven to the position_sp set in the
     * `position_sp` attribute. Setting to `float` will remove power from the motor.
     */
    command: string;
    /**
     * Returns the name of the motor driver that loaded this device. See the list
     * of [supported devices] for a list of drivers.
     */
    driverName: string;
    /**
     * Used to set the pulse size in milliseconds for the signal that tells the
     * servo to drive to the maximum (clockwise) position_sp. Default value is 2400.
     * Valid values are 2300 to 2700. You must write to the position_sp attribute for
     * changes to this attribute to take effect.
     */
    /**
     * Used to set the pulse size in milliseconds for the signal that tells the
     * servo to drive to the maximum (clockwise) position_sp. Default value is 2400.
     * Valid values are 2300 to 2700. You must write to the position_sp attribute for
     * changes to this attribute to take effect.
     */
    maxPulseSp: number;
    /**
     * Used to set the pulse size in milliseconds for the signal that tells the
     * servo to drive to the mid position_sp. Default value is 1500. Valid
     * values are 1300 to 1700. For example, on a 180 degree servo, this would be
     * 90 degrees. On continuous rotation servo, this is the 'neutral' position_sp
     * where the motor does not turn. You must write to the position_sp attribute for
     * changes to this attribute to take effect.
     */
    /**
     * Used to set the pulse size in milliseconds for the signal that tells the
     * servo to drive to the mid position_sp. Default value is 1500. Valid
     * values are 1300 to 1700. For example, on a 180 degree servo, this would be
     * 90 degrees. On continuous rotation servo, this is the 'neutral' position_sp
     * where the motor does not turn. You must write to the position_sp attribute for
     * changes to this attribute to take effect.
     */
    midPulseSp: number;
    /**
     * Used to set the pulse size in milliseconds for the signal that tells the
     * servo to drive to the miniumum (counter-clockwise) position_sp. Default value
     * is 600. Valid values are 300 to 700. You must write to the position_sp
     * attribute for changes to this attribute to take effect.
     */
    /**
     * Used to set the pulse size in milliseconds for the signal that tells the
     * servo to drive to the miniumum (counter-clockwise) position_sp. Default value
     * is 600. Valid values are 300 to 700. You must write to the position_sp
     * attribute for changes to this attribute to take effect.
     */
    minPulseSp: number;
    /**
     * Sets the polarity of the servo. Valid values are `normal` and `inversed`.
     * Setting the value to `inversed` will cause the position_sp value to be
     * inversed. i.e `-100` will correspond to `max_pulse_sp`, and `100` will
     * correspond to `min_pulse_sp`.
     */
    /**
     * Sets the polarity of the servo. Valid values are `normal` and `inversed`.
     * Setting the value to `inversed` will cause the position_sp value to be
     * inversed. i.e `-100` will correspond to `max_pulse_sp`, and `100` will
     * correspond to `min_pulse_sp`.
     */
    polarity: string;
    /**
     * Returns the name of the port that this motor is connected to.
     */
    address: string;
    /**
     * Reading returns the current position_sp of the servo. Writing instructs the
     * servo to move to the specified position_sp. Units are percent. Valid values
     * are -100 to 100 (-100% to 100%) where `-100` corresponds to `min_pulse_sp`,
     * `0` corresponds to `mid_pulse_sp` and `100` corresponds to `max_pulse_sp`.
     */
    /**
     * Reading returns the current position_sp of the servo. Writing instructs the
     * servo to move to the specified position_sp. Units are percent. Valid values
     * are -100 to 100 (-100% to 100%) where `-100` corresponds to `min_pulse_sp`,
     * `0` corresponds to `mid_pulse_sp` and `100` corresponds to `max_pulse_sp`.
     */
    positionSp: number;
    /**
     * Sets the rate_sp at which the servo travels from 0 to 100.0% (half of the full
     * range of the servo). Units are in milliseconds. Example: Setting the rate_sp
     * to 1000 means that it will take a 180 degree servo 2 second to move from 0
     * to 180 degrees. Note: Some servo controllers may not support this in which
     * case reading and writing will fail with `-EOPNOTSUPP`. In continuous rotation
     * servos, this value will affect the rate_sp at which the speed ramps up or down.
     */
    /**
     * Sets the rate_sp at which the servo travels from 0 to 100.0% (half of the full
     * range of the servo). Units are in milliseconds. Example: Setting the rate_sp
     * to 1000 means that it will take a 180 degree servo 2 second to move from 0
     * to 180 degrees. Note: Some servo controllers may not support this in which
     * case reading and writing will fail with `-EOPNOTSUPP`. In continuous rotation
     * servos, this value will affect the rate_sp at which the speed ramps up or down.
     */
    rateSp: number;
    /**
     * Returns a list of flags indicating the state of the servo.
     * Possible values are:
     * * `running`: Indicates that the motor is powered.
     */
    state: string[];
}
/**
 * Describes a setpoint for a motor's power/speed. Supports both
 * unregulated (raw power) and regulated (specific speed) modes.
 */
export declare class MotorSpeedSp {
    regulationEnabled: string;
    dutyCycleSp: number;
    speedSp: number;
    constructor(dutyCycleSp?: number);
    static fromRegulated(speedSp: number): MotorSpeedSp;
    static fromUnregulated(dutyCycleSp: number): MotorSpeedSp;
}
