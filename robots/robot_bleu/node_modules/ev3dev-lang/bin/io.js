/// <reference path="node.d.ts" />
var fs = require('fs');
var path = require('path');
var XError = (function () {
    function XError() {
        var tsargs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tsargs[_i - 0] = arguments[_i];
        }
        Error.apply(this, arguments);
        return new Error();
    }
    return XError;
})();
XError['prototype'] = new Error();
var TraceError = (function () {
    function TraceError(message, innerError) {
        this.message = message;
        this.innerError = innerError;
    }
    TraceError.prototype.toString = function () {
        var str = this.message.trim() + '\r\nInner error:\r\n';
        var innerLines = this.innerError.toString().split('\r\n');
        for (var i in innerLines) {
            innerLines[i] = '  ' + innerLines[i];
        }
        return str + innerLines.join('\r\n');
    };
    return TraceError;
})();
exports.TraceError = TraceError;
var Device = (function () {
    function Device() {
        this.connected = false;
        this.sysClassDir = '/sys/class';
    }
    Device.prototype.connect = function (driverName, nameConvention, propertyConstraints) {
        var nameRegex = nameConvention == undefined ? undefined : new RegExp(nameConvention);
        var deviceSearchDir = path.join(this.sysClassDir, driverName);
        var availableDevices;
        try {
            availableDevices = fs.readdirSync(deviceSearchDir);
        }
        catch (error) {
            return;
        }
        for (var deviceDirIndex in availableDevices) {
            var currentDeviceDirName = availableDevices[deviceDirIndex];
            if (nameRegex != undefined && !nameRegex.test(currentDeviceDirName))
                continue;
            var currentDeviceDir = path.join(deviceSearchDir, currentDeviceDirName);
            var satisfiesConstraints = true;
            if (propertyConstraints != undefined) {
                for (var propName in propertyConstraints) {
                    var propertyValue = this.readProperty(propName, currentDeviceDir);
                    var constraintValue = propertyConstraints[propName];
                    if (constraintValue instanceof Array) {
                        if (constraintValue.indexOf(propertyValue) === -1) {
                            satisfiesConstraints = false;
                        }
                    }
                    else if (propertyValue != constraintValue) {
                        satisfiesConstraints = false;
                    }
                }
            }
            if (!satisfiesConstraints)
                continue;
            this.deviceRoot = currentDeviceDir;
            this.deviceDirName = currentDeviceDirName;
            this.connected = true;
        }
    };
    Device.prototype.constructPropertyPath = function (property, deviceRoot) {
        return path.join(deviceRoot || this.deviceRoot, property);
    };
    Device.prototype.readNumber = function (property, deviceRoot) {
        var value = this.readProperty(property, deviceRoot);
        if (typeof value !== 'number')
            return NaN;
        return value;
    };
    Device.prototype.readString = function (property, deviceRoot) {
        var value = this.readProperty(property, deviceRoot);
        return String(value);
    };
    Device.prototype.readStringArray = function (property, deviceRoot) {
        return this.readString(property, deviceRoot)
            .split(' ')
            .map(function (value) { return value.replace(/^\[|\]$/g, ''); });
    };
    Device.prototype.readStringSelector = function (property, deviceRoot) {
        var bracketedParts = this.readString(property, deviceRoot)
            .split(' ')
            .filter(function (value) { return value.match(/^\[|\]$/g) != null; });
        if (bracketedParts.length <= 0)
            return null;
        return bracketedParts[0].replace(/^\[|\]$/g, '');
    };
    Device.prototype.readProperty = function (property, deviceRoot) {
        if (!deviceRoot && !this.connected)
            throw new Error('You must be connected to a device before you can read from it. This error probably means that the target device was not found.');
        var rawValue;
        var propertyPath = this.constructPropertyPath(property, deviceRoot);
        try {
            rawValue = fs.readFileSync(propertyPath).toString();
        }
        catch (e) {
            throw new TraceError('There was an error while reading from the property file "' + propertyPath + '".', e);
        }
        rawValue = rawValue.trim();
        var numValue = Number(rawValue);
        if (isNaN(numValue))
            return rawValue;
        else
            return numValue;
    };
    Device.prototype.setProperty = function (property, value) {
        if (!this.connected)
            throw new Error('You must be connected to a device before you can write to it. This error probably means that the target device was not found.');
        var propertyPath = this.constructPropertyPath(property);
        try {
            fs.writeFileSync(propertyPath, value.toString());
        }
        catch (e) {
            throw new TraceError('There was an error while writing to the property file "' + propertyPath + '".', e);
        }
    };
    Device.prototype.setNumber = function (property, value) {
        this.setProperty(property, value);
    };
    Device.prototype.setString = function (property, value) {
        this.setProperty(property, value);
    };
    Device.prototype.set = function (propertyDefs) {
        for (var key in propertyDefs) {
            this.setProperty(key, propertyDefs[key]);
        }
    };
    return Device;
})();
exports.Device = Device;
//# sourceMappingURL=io.js.map