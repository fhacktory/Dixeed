var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var IO = require('./io');
var Device = IO.Device;
var SensorBase = (function (_super) {
    __extends(SensorBase, _super);
    function SensorBase(driverTypeDirName, nameConvention, targetAddress, targetDriverName) {
        _super.call(this);
        this._deviceIndex = -1;
        var propertyConstraints = {};
        if (targetAddress != undefined)
            propertyConstraints['address'] = targetAddress;
        if (targetDriverName != undefined)
            propertyConstraints['driver_name'] = [].concat(targetDriverName);
        this.connect(driverTypeDirName, nameConvention, propertyConstraints);
        if (this.connected) {
            var matches = new RegExp(nameConvention).exec(this.deviceDirName);
            if (matches != null && matches[0] != undefined) {
                this._deviceIndex = Number(matches[1]);
            }
        }
    }
    Object.defineProperty(SensorBase.prototype, "deviceIndex", {
        get: function () {
            return this._deviceIndex;
        },
        enumerable: true,
        configurable: true
    });
    return SensorBase;
})(Device);
exports.SensorBase = SensorBase;
//~autogen generic-class-description classes.sensor>currentClass
/**
 * The sensor class provides a uniform interface for using most of the
 * sensors available for the EV3. The various underlying device drivers will
 * create a `lego-sensor` device for interacting with the sensors.
 *
 * Sensors are primarily controlled by setting the `mode` and monitored by
 * reading the `value<N>` attributes. Values can be converted to floating point
 * if needed by `value<N>` / 10.0 ^ `decimals`.
 *
 * Since the name of the `sensor<N>` device node does not correspond to the port
 * that a sensor is plugged in to, you must look at the `address` attribute if
 * you need to know which port a sensor is plugged in to. However, if you don't
 * have more than one sensor of each type, you can just look for a matching
 * `driver_name`. Then it will not matter which port a sensor is plugged in to - your
 * program will still work.
 */
//~autogen
var Sensor = (function (_super) {
    __extends(Sensor, _super);
    function Sensor(port, driverNames) {
        //~autogen connect-super-call classes.sensor>currentClass "port,driverNames">extraParams
        _super.call(this, 'lego-sensor', 'sensor(\\d*)', port, driverNames);
        //~autogen
    }
    Sensor.prototype.getValue = function (valueIndex) {
        return this.readNumber("value" + valueIndex);
    };
    Sensor.prototype.getFloatValue = function (valueIndex) {
        return this.getValue(valueIndex) / Math.pow(10, this.decimals);
    };
    Object.defineProperty(Sensor.prototype, "command", {
        //PROPERTIES
        //~autogen generic-get-set classes.sensor>currentClass
        /**
         * Sends a command to the sensor.
         */
        set: function (value) {
            this.setString("command", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sensor.prototype, "commands", {
        /**
         * Returns a list of the valid commands for the sensor.
         * Returns -EOPNOTSUPP if no commands are supported.
         */
        get: function () {
            return this.readStringArray("commands");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sensor.prototype, "decimals", {
        /**
         * Returns the number of decimal places for the values in the `value<N>`
         * attributes of the current mode.
         */
        get: function () {
            return this.readNumber("decimals");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sensor.prototype, "driverName", {
        /**
         * Returns the name of the sensor device/driver. See the list of [supported
         * sensors] for a complete list of drivers.
         */
        get: function () {
            return this.readString("driver_name");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sensor.prototype, "mode", {
        /**
         * Returns the current mode. Writing one of the values returned by `modes`
         * sets the sensor to that mode.
         */
        get: function () {
            return this.readString("mode");
        },
        /**
         * Returns the current mode. Writing one of the values returned by `modes`
         * sets the sensor to that mode.
         */
        set: function (value) {
            this.setString("mode", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sensor.prototype, "modes", {
        /**
         * Returns a list of the valid modes for the sensor.
         */
        get: function () {
            return this.readStringArray("modes");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sensor.prototype, "numValues", {
        /**
         * Returns the number of `value<N>` attributes that will return a valid value
         * for the current mode.
         */
        get: function () {
            return this.readNumber("num_values");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sensor.prototype, "address", {
        /**
         * Returns the name of the port that the sensor is connected to, e.g. `ev3:in1`.
         * I2C sensors also include the I2C address (decimal), e.g. `ev3:in1:i2c8`.
         */
        get: function () {
            return this.readString("address");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sensor.prototype, "units", {
        /**
         * Returns the units of the measured value for the current mode. May return
         * empty string
         */
        get: function () {
            return this.readString("units");
        },
        enumerable: true,
        configurable: true
    });
    return Sensor;
})(SensorBase);
exports.Sensor = Sensor;
//~autogen sensor-helper-classes
/**
 * Touch Sensor
 */
var TouchSensor = (function (_super) {
    __extends(TouchSensor, _super);
    function TouchSensor(port) {
        _super.call(this, port, ["lego-ev3-touch", "lego-nxt-touch"]);
    }
    Object.defineProperty(TouchSensor.prototype, "isPressed", {
        /**
         * A boolean indicating whether the current touch sensor is being
         * pressed.
         */
        get: function () {
            this.mode = 'TOUCH';
            return Boolean(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    return TouchSensor;
})(Sensor);
exports.TouchSensor = TouchSensor;
/**
 * LEGO EV3 color sensor.
 */
var ColorSensor = (function (_super) {
    __extends(ColorSensor, _super);
    function ColorSensor(port) {
        _super.call(this, port, ["lego-ev3-color"]);
    }
    Object.defineProperty(ColorSensor.prototype, "reflectedLightIntensity", {
        /**
         * Reflected light intensity as a percentage. Light on sensor is red.
         */
        get: function () {
            this.mode = 'COL-REFLECT';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorSensor.prototype, "ambientLightIntensity", {
        /**
         * Ambient light intensity. Light on sensor is dimly lit blue.
         */
        get: function () {
            this.mode = 'COL-AMBIENT';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorSensor.prototype, "color", {
        /**
         * Color detected by the sensor, categorized by overall value.
         *   - 0: No color
         *   - 1: Black
         *   - 2: Blue
         *   - 3: Green
         *   - 4: Yellow
         *   - 5: Red
         *   - 6: White
         *   - 7: Brown
         */
        get: function () {
            this.mode = 'COL-COLOR';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorSensor.prototype, "red", {
        /**
         * Red component of the detected color, in the range 0-1020.
         */
        get: function () {
            this.mode = 'RGB-RAW';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorSensor.prototype, "green", {
        /**
         * Green component of the detected color, in the range 0-1020.
         */
        get: function () {
            this.mode = 'RGB-RAW';
            return Number(this.getFloatValue(1));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorSensor.prototype, "blue", {
        /**
         * Blue component of the detected color, in the range 0-1020.
         */
        get: function () {
            this.mode = 'RGB-RAW';
            return Number(this.getFloatValue(2));
        },
        enumerable: true,
        configurable: true
    });
    return ColorSensor;
})(Sensor);
exports.ColorSensor = ColorSensor;
/**
 * LEGO EV3 ultrasonic sensor.
 */
var UltrasonicSensor = (function (_super) {
    __extends(UltrasonicSensor, _super);
    function UltrasonicSensor(port) {
        _super.call(this, port, ["lego-ev3-us", "lego-nxt-us"]);
    }
    Object.defineProperty(UltrasonicSensor.prototype, "distanceCentimeters", {
        /**
         * Measurement of the distance detected by the sensor,
         * in centimeters.
         */
        get: function () {
            this.mode = 'US-DIST-CM';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UltrasonicSensor.prototype, "distanceInches", {
        /**
         * Measurement of the distance detected by the sensor,
         * in inches.
         */
        get: function () {
            this.mode = 'US-DIST-IN';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UltrasonicSensor.prototype, "otherSensorPresent", {
        /**
         * Value indicating whether another ultrasonic sensor could
         * be heard nearby.
         */
        get: function () {
            this.mode = 'US-LISTEN';
            return Boolean(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    return UltrasonicSensor;
})(Sensor);
exports.UltrasonicSensor = UltrasonicSensor;
/**
 * LEGO EV3 gyro sensor.
 */
var GyroSensor = (function (_super) {
    __extends(GyroSensor, _super);
    function GyroSensor(port) {
        _super.call(this, port, ["lego-ev3-gyro"]);
    }
    Object.defineProperty(GyroSensor.prototype, "angle", {
        /**
         * The number of degrees that the sensor has been rotated
         * since it was put into this mode.
         */
        get: function () {
            this.mode = 'GYRO-ANG';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GyroSensor.prototype, "rate", {
        /**
         * The rate at which the sensor is rotating, in degrees/second.
         */
        get: function () {
            this.mode = 'GYRO-RATE';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    return GyroSensor;
})(Sensor);
exports.GyroSensor = GyroSensor;
/**
 * LEGO EV3 infrared sensor.
 */
var InfraredSensor = (function (_super) {
    __extends(InfraredSensor, _super);
    function InfraredSensor(port) {
        _super.call(this, port, ["lego-ev3-ir"]);
    }
    Object.defineProperty(InfraredSensor.prototype, "proximity", {
        /**
         * A measurement of the distance between the sensor and the remote,
         * as a percentage. 100% is approximately 70cm/27in.
         */
        get: function () {
            this.mode = 'IR-PROX';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    return InfraredSensor;
})(Sensor);
exports.InfraredSensor = InfraredSensor;
/**
 * LEGO NXT Sound Sensor
 */
var SoundSensor = (function (_super) {
    __extends(SoundSensor, _super);
    function SoundSensor(port) {
        _super.call(this, port, ["lego-nxt-sound"]);
    }
    Object.defineProperty(SoundSensor.prototype, "soundPressure", {
        /**
         * A measurement of the measured sound pressure level, as a
         * percent. Uses a flat weighting.
         */
        get: function () {
            this.mode = 'DB';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundSensor.prototype, "soundPressureLow", {
        /**
         * A measurement of the measured sound pressure level, as a
         * percent. Uses A-weighting, which focuses on levels up to 55 dB.
         */
        get: function () {
            this.mode = 'DBA';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    return SoundSensor;
})(Sensor);
exports.SoundSensor = SoundSensor;
/**
 * LEGO NXT Light Sensor
 */
var LightSensor = (function (_super) {
    __extends(LightSensor, _super);
    function LightSensor(port) {
        _super.call(this, port, ["lego-nxt-light"]);
    }
    Object.defineProperty(LightSensor.prototype, "reflectedLightIntensity", {
        /**
         * A measurement of the reflected light intensity, as a percentage.
         */
        get: function () {
            this.mode = 'REFLECT';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightSensor.prototype, "ambientLightIntensity", {
        /**
         * A measurement of the ambient light intensity, as a percentage.
         */
        get: function () {
            this.mode = 'AMBIENT';
            return Number(this.getFloatValue(0));
        },
        enumerable: true,
        configurable: true
    });
    return LightSensor;
})(Sensor);
exports.LightSensor = LightSensor;
//~autogen
//~autogen generic-class-description classes.i2cSensor>currentClass
/**
 * A generic interface to control I2C-type EV3 sensors.
 */
//~autogen
var I2CSensor = (function (_super) {
    __extends(I2CSensor, _super);
    function I2CSensor(port, driverNames) {
        _super.call(this, port, driverNames);
    }
    Object.defineProperty(I2CSensor.prototype, "fwVersion", {
        //~autogen generic-get-set classes.i2cSensor>currentClass
        /**
         * Returns the firmware version of the sensor if available. Currently only
         * I2C/NXT sensors support this.
         */
        get: function () {
            return this.readString("fw_version");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(I2CSensor.prototype, "pollMs", {
        /**
         * Returns the polling period of the sensor in milliseconds. Writing sets the
         * polling period. Setting to 0 disables polling. Minimum value is hard
         * coded as 50 msec. Returns -EOPNOTSUPP if changing polling is not supported.
         * Currently only I2C/NXT sensors support changing the polling period.
         */
        get: function () {
            return this.readNumber("poll_ms");
        },
        /**
         * Returns the polling period of the sensor in milliseconds. Writing sets the
         * polling period. Setting to 0 disables polling. Minimum value is hard
         * coded as 50 msec. Returns -EOPNOTSUPP if changing polling is not supported.
         * Currently only I2C/NXT sensors support changing the polling period.
         */
        set: function (value) {
            this.setNumber("poll_ms", value);
        },
        enumerable: true,
        configurable: true
    });
    return I2CSensor;
})(Sensor);
exports.I2CSensor = I2CSensor;
//# sourceMappingURL=sensors.js.map